<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Lecture - python</title>
    <link href="styles.css" rel="stylesheet">
</head>
<body>
    <header>
        <nav>
            <div class="header_title">Python Algorithm</div>
            <div class = "header_nav">
                <a href="#introdution">introndution</a>
                <a href="#tree">정렬 & 트리</a>
                <a href="#hashing">해싱</a>
                <a href="#rsa">RSA</a>
                <a href="#graph">그래프</a>
                <a href="#short">최단경로</a>
                <a href="#dynamic">동적</a>
                <a href="#advanced">Advanced</a>
            </div>
        </nav>
    </header>
    <main>
        <div class = "section main_introdution" id="introdution">
            <head><h2>1. introndution</h2></head>
            <h3>Information</h3>
            <pre>
                Information - http://coursescail.mit.edu/6.006
                다루는 내용: 대규모 입력이 필요한 문제들을 해결하기 위한 효율적인 방법
                Focus on 큰값 -> 효율성
                - 확장성
                - classic data structure
                - Real-  implementation in python
                어떤게 효율적인지 찾아내고 증명하는 과정 진행

                About 연습문제
                1. 자료구조의 특정 정렬 알고리즘을 이용 논리 네트워크 시뮬레이션
                2. 해싱 단원 -> 게놈 비교에 이용
                3. numeric(거대한 수) -> SSL에서 이용 백엔드에서 RSA가 사용
                4. 그래프 -> 루빅 큐브 필요한 이동 최소값
                5. 최단 경로 -> caltech -> MIT 거리
                6. 동적 프로그래밍 -> 이미지 압축, 픽셀 줄이기
                7. Advanced topics 
            </pre>
        
            <h3>극대값 찾기- 1차원과 2차원의 경우</h3>
            <pre>
                <strong>1차원</strong>
                양수 -> 극대값 찾기 (9자리)
                a b c d e f g h i 
                - b가 극대값이라고 한다면
                b >= a and b >=c
                즉 극대 값은 지역적인 요소이다.
                - 가장자리가 극대값이라고 한다면
                i >= h

                <strong>Q. 극대값이 존재하는 경우에 극대값을 찾아라</strong>
                존재하는 경우라고 하는 경우라고 하는 이유는 이를 증명해야하기 때문이다.
                원소 n개 
                1,2,3,...,n-1,n
                왼쪽 -> 오른쪽으로 이동하면서 확인
                중간에 있는 경우 n/2
                최악의 경우 n

                <strong>어떻게 접근할 수 있을까</strong>
                이진 탐색을 이용한 접근
                if a [n/2] < a[n/2-1] 왼쪽 절반만 보기
                else if a[n/2] < a[n/2+1] 오른쪽 
                else : 중앙값이  peak

                <strong>More better을 위한 복잡도 접근</strong>
                살펴본 복잡도 O(n)의 효율을 조금 더 개선하기 위한 알고리즘 접근
                재귀적 분할 정복 알고리즘에 대응하는 점화식 T(n)
                T(n) -> 알고리즘이 하는 일의 양 
                <i>T(n) = T(n/2) + O(1)</i>
                여기 식에서 O(1)은 왼쪽 오른쪽을 확인하는 시간은 상수 2 이므로 O(1)됨
                위 식을 전개하면 T(1) = O(1) 원소가 한개인 배열에서는 그 원소를 반환하기 때문이다
                T(n) = O(1) + ..... + O(1) = O(log2n)
                n -> 1000만 O(n) -> 13초
                            O(log2n) -> 0.001초
                
                <strong>2차원 배열</strong>
                행렬 행 n 열 m 
                극대값 -> 확실한 정의는 극대값 = 언덕
                a >= b,c,d,e 이면 극대값
                Greed Ascent Algorithm -> 방향을 따라 극대값을 찾음
                특정 값에서 시작하여 왼쪽 값이 크면 그 방향으로 가고,
                아니면 그 반대 방향으로 탐색
                최악의 경우라면? 시작 지점에 상관없이 모든 방향으로 거처가야할 수 있음
                그렇다면 복잡도는 O(n*m) n = m 이라면 O(n^2)

                <strong>분활 정복 알고리즘</strong>
                2차원 -> 이진 탐색을 이용해 보기
                1. 중앙열 선택 j = m/2
                2. 1차원의 극대 값 찾기 -> 이진 탐색 알고리즘
                Use (i,j) as a stant to  find a 1D-peak on row
                -> 복잡도 O(log2n) 한번 수행 했을 때 효율적이지만 제대로 작동하지 않음
                Why? -> 그행에 존재하지 않을 수도 있음 
                Real Algorithm -> 재귀 알고리즘 -> 중앙열 선택
                <i>

                    1. pick middle column j = m/2
                    2. find global max on colmn j at (j,i)
                    3. compare (i, j-1) (i,j) (i,j+1)
                    4. pick left cols if (i,j-1) > (i,j) left similar case in right
                    Even in fact, either of these two condition don't fire 
                    -> (i,j) is peak 
                    Overall, 
                    T(n,m) = T(n,m/2) + O(n) <- max
                    T(n,1) = O(n)이 탈출 조건
                    T(m,m) = O(n) + .... + O(n)
                    -> log2m번 더해진다 -> nlog2m
                </i>
            </pre>

            <h3>계산모델</h3>
            <pre>
                <strong>알고리즘</strong>
                What is time? what is running time?
                알고리즘의 유래
                - 대수학의 아버지
                - 대수학과 알고리즘이 나옴
                what is algorithm?
                Abstract 문제를 푸는 계산이나 방법
                input -> alg -> output
                문제를 풀기 위한 수학적 표현
                컴퓨터에 대항하는 수학적 언어 -> 프로그래밍 언어
                
                <strong>계산 모델</strong>
                알고리즘이 할 수 있는 연산
                연산에 걸리는 시간 비용 -> 실행 시간을 모두 더하면 비용이 된다.
                
                <strong> 2가지 계산 모델 </strong>
                <big>Random Access Machine(RAM)</big> 
                <big>Random Access Memory</big>
                RAM은 두가지 의미를 가지지만 여기서 얘기하는 것은 Machine
                memory
                핵심은 Ram은 일련에 배열이다. 
                배열을 O(1)안에 모두 접근가능하다. 접근을 하기 위해서는 어디있는지 알아야 하는데
                그것이 임의 기억 장치이다.
                RAM -> 주로 word로 조직되어 있다. 
                0,1,2,3,4...... 배열로 되어 있고, 저장공간은 무한대이거나 알고리즘의 공간만큼이라고 가정한다.
                실제 계산
                알고리즘은 O(1)시간 동안,
                메모리로부터 상수개의 워드를 불러낼 수 있고, 
                계산을 수행하 수 있고 메모리에 저장할 수 있다. 
                word가 어디에 있는지는 주소를 통해 알아낸다. 

                상수 개의 레지스터있다고 가정하자. 그럼
                Assembly algorithm proccess
                word ->> register
                caculate in the register
                record in register assigned

                <strong>Word가 무엇인가?</strong>
                현대 컴퓨터는 32bit or 64bit
                word : W bit
                W의 메모리 크기는 log 이상이어야 한다. 
                왜냐하면 워드가 이 배열의 인덱스를 지정할 수 있어야 하기 때문이다. 
                그럼 워드에 맞지 않는 거대한 정수는 어떻게 처리? 일단 한개의 워드로 가정
                
                <big>Pointer Access Machine(PAK)</big>
                객체지향 프로그래밍
                동적 할당이 가능하다
                하나의 객체는 특정수의 field를 가진다
                field는 정수 객체 카운터 포인터 등등 뭐든 될 수 있다
                포인터는 다른 객체를 가리키거나 or null nil None
                결국 reference 모델인 것이다.

                예를 들어 연결리스트,
                연결리스트는 각 노드마다 여러개의 field가 있다. 
                이전이다 다음 요소를 가리키는 포인터와 value값을 가진다. 
                양쪽을 가리키면 이중 연결 리스트
                리스트 머리를 가리키는 포인터와 꼬리를 가리키는 포인터가 있다고 할 수 있다.
                이것이 포인터 machine 자료구조이다. 
                파이썬에서는 named 튜플
                이것을 RAM에서 만들면 거대한 배열이 된다. 

                <strong>Python model에서는?</strong>
                파이썬에서는 -> 실행 시간이 많이 걸린다. 
                위에는 기본적인 이론은 이론적으로는 상수시간이 걸리는 것이 맞으나, 파이썬은 연산시간이 꽤나 걸린다.
                파이썬은 현실세계에 리스트와 비슷하다. 
                list = array
                여기서 리스트는 연결리스트가 아니다. 
                L[i] = L[j]+5 라고 한다면 리스트는 바로 상수를 찾으므로 상수시간이지만
                연결리스트는 i 위치를 훑고나서 j위치까지 훑고 저장한다.
                파이썬은 상수시간이 걸리므로 -> list array

                연결리스트를 구현한다고 하면
                x = x.next  -> O(1)
                L.append(x) -> 비용을 알기 위해 어떻게 기본연산들로 구성되어 있는지
                이는 특정 크기의 배열이 있는데 배열의 크기를 한칸 더 늘리고 싶은 것이다.
                확실한 방법은 새로운 배열을 할당하여 모든 요소를 복사하는 것인데.. 이러면 n 만큼의 시간이 소요됨
                그런데 상수 시간안에 가능하다 O(1)
                -> 이를 Table dubbling이라고 한다. 
                connect = L1 + L2 리스트를 합치려면 복사해서 합친다. 
                이는
                L = []
                for x in L1:
                    L.append(x)
                for x in L2:
                    L.append(x)
                를 의미한다. 상수시간 더하기 상수시간
                그래서 총시간은 O(1+L1의 길이 + L2의 길이)
                x in L 이것은 실행시간이 얼마나 걸릴까? O(n) 선형 시간

                <big>그렇다면 리스트 길이를 계산하는데 얼마나 걸릴까?</big>
                상수시간이다. 
                원래는 리스트를 끝까지 읽어서 항목을 세야하는데,
                파이썬에는 카운터가 내장되어 있다. 

                <strong>리스트 정렬 시간</strong>
                nlogn (n은 비교하는 시간)
                두 항목을 비교하는 시간에도 곱해지는데 보통 항목이 word이므로
                상수시간을 갖는다. 
                파이선 sort()는 어떻게 n logn이 되는지 알아볼 것이다. 

                <strong>dictionary</strong>
                dict: D[key] = value -> O(1)
                이것이 해시 테이블에서 상수시간으로 이루어 지는지 주목. 
                그럼 dict안에 key가 있는지 부터 알아보는가
                -> 일단 이미 존재하는 키는 덮어쓴다. key in dict해도 알 수 있다. 
                이것도 상수 시간 
                정확하게 이야기 하면 높은 확률로 상수시간이고 항상 상수시간은 아니다. 
                
                <strong>Long</strong>
                long은 파이썬ver 2에서 long 정수이다.
                x + y O(|x|+|y|)
                x x y O((|x|+|y|)^log<small>2</small>3)
                log<small>2</small>3 = 1.6 간단한 곱셈보다 조금 더 빠르고 효율적
                

                <strong>문서 거리</strong>
                Document distance problem
                D1 D2사이의 거리
                d(D1, D2)
                예를 들면 실제로 구글에서 전체 웹을 분류한다고 가정
                그럼 기본적으로 두 웹페이지가 기본적으로 동일한지 알고 싶다. 
                이때 일일히 찾지 않고 distance로 해결할 수 있다. 
                이번에는 검색엔진을 구현한다고 해보자
                두 단어를 검색하는데 문서와 유사정도를 계산하여 distance가 가장 짧은 것을 보여줄 것이다.
                <i>Formal</i>
                문서 -> 단어들의 나열
                단어 -> 문자열
                공통단어 -> 문서의 거리 측정
                문서 -> 단어들의 나열, 하나의 백터
                문서 D와 단어 w ->  D[w] -> 단어가 문서에서 등장하는 횟수
                <i>EX)</i>
                문서 두개 있다.
                D1= "the cat"
                D2= "the dog"
                ->  여기서 서로다른 단어가 3개 존재하므로 3차원공간으로 표현 가능
                the축 cat축 dog축
                <img src="part-introduce(document distance).png" style="width:150px; height: 150px; margin:10px 10px; border-radius: 10px;">
                
                어떻게 이 벡터에 접근할 수 있을까?
                sol 1.
                d'(D1,D2) = D1·D2(둘을 내적함)
                모든 단어에 대해 D1[w]와 D2[w]를 더한 것과 같다. 
                그럼 여기서 the가 일치하므로 -> 1점
                cat과 dog는 0이 곱해져 더해지는 것이 없음.
                만약 공통 단어가 많다면 값이 커지겠죠.. 

                근데 이게 몇 만개의 문서가 있는데 99%의 distance가 나왔다면?
                아마도 매우 유사한 형태의 document일 것이다. 
                하지만 값에 따라 조금씩 달라지므로 완벽한 지표는 아니다. 

                sol 2.
                벡터의 길이로 나누기
                d(D1, D2) -> divide = D1·D2 / |D1|·|D2|
                이 식은 각도식이다. 안정적인 거리 함수 -> arccos( D1·D2 / |D1|·|D2|)
                각도에 따라 얼마나 공통적인지가 판단됨. 
                90º의 경우 완전히 다름. 
                
                어쨌든 3단계의 알고리즘이 필요
                1. 문서를 단어로 쪼갬
                2. 단어 빈도 계산 -> 문서 벡터
                3. 내적 계산

                ver1. 1MB정도의 문서 한쌍 228.1초
                알고리즘을 변형시킬 때 마다
                ->164.7->123.1->71.7->18.3->11.5->1.8->0.2초로 줄어듦. 
                큰 문서일 수록 그 차이는 더 커질 것이다. 

                <strong>문서를 어떻게 쪼갤까?</strong>
                단어 반복하면서 dict에 넣음
                for word in dic:
                    count[word] += 1
                단어가 매우 길 수도있기 때문에 Machine word로 줄이면
                O(word길이) 문서들의 있는 단어들의 길이만큼의 시간
                re.findall(r'\w+',doc) // 정규 표현식
                re는 모든 단어를 찾을 수 있지만 지수 시간 만큼 시간이 소요
                re는 복잡한 일을 할 때만 쓰세요.. 잘 알면 써도 상관 없고..  
                
            </pre>

        </div>
        <div class = "section main_tree" id="tree">
            <head><h2>2. 정렬 & 트리</h2></head>
            <h3>삽입 정렬과 합병 정렬</h3>
            <pre>
                C언어
            </pre>

            <h3>힙 & 힙 정렬 </h3>
            <pre>
                dkssud
            </pre>
            
            <h3>일정 예약과 이진 탐색 트리</h3>
            <pre>
                dk ssud
            </pre>

            <h3>균형 이진 탐색 트리</h3>
            <pre>
                dkssud
            </pre>

            <h3>선형 시간 정렬</h3>
            <pre>
                dkssud
            </pre>

        </div>
        <div class = "section main_hashing" id="hashing">
            <head><h2>3. 해싱</h2></head>
            <h3>알고리즘</h3>
            <pre>
                배열
            </pre>
        </div>
        <div class = "section main_RSA" id="rsa">
            <head><h2>4. RSA</h2></head>
            <h3>알고리즘</h3>
            <pre>
                알고리즘
            </pre>
        </div>
        <div class = "section main_graph" id="graph">
            <head><h2>5. 그래프</h2></head>
            <h3>알고리즘</h3>
            <pre>
                메모리
            </pre>
        </div>
        <div class = "section main_shortway" id="short">
            <head><h2>6. 최단경로</h2></head>
            <h3>알고리즘</h3>
            <pre>
                자료 구조
            </pre>
        </div>
        <div class = "section main_dynamic" id="dynamic">
            <head><h2>7. 동적</h2></head>
            <h3>알고리즘</h3>
            <pre>
                자료 구조
            </pre>
        </div>
        <div class = "section main_advanced" id="advanced">
            <head><h2>8. Advanced</h2></head>
            <h3>알고리즘</h3>
            <pre>
                자료 구조
            </pre>
        </div>
        <div class = "pageTop">
            <a href="#">+</a>
        </div>
    </main>
  
    <foodter>

    </foodter>
    
</body>
</html>