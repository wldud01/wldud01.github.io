<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>
    <link rel="stylesheet" href="../all_styles.css">
</head>
<body>
    <h3>What is React</h3>
    <pre>
        사용자 인터페이스를 만들기 위한 라이브러리
        라이브러리 - 자주 사용되는 기능들을 모아놓은 것
        UI - 입출력 제어해주는 것 button.. 
        Ngularjs  vue.js  React
        프레임워크 제어 권한 -> 프레임워크
        라이브러리 제어 권한 -> 개발자
    
        사용자와의 상호작용을 위한 인터페이스를 만들면서 관리하려고 만든
        자바스크립트 SPA(single page application)

        <strong>장점</strong>
        빠른 업데이트와 렌더링
        virtual DOM -> 가상의 돔 
        DOM -> 웹페이지 정보를 가진 큰 그릇
        즉 가상 돔은 실제 돔과 웹페이지 사이에서 그 중간 매게체 역할이라고 봄
        최소한의 부분만 update 하기 때문에 빠름(일반은 )
        component - based -> 블록을 조립하듯한 구조
        componet로 아루어진 웹사이트라는 소리
        반복적으로 사용되는 component

        <strong>재사용성 </strong>
        -> 다시 사용이 가능한 성질
        -> 새로운 것을 계속 불러와서 사용
        -> 호환성 문제가 없도록 개발할 수 있도록 만든다.
        -> 그래서 API..
        -> 리액트는 항상 쉽고 재사용성 잘 생각하기
        -> react sponsor meta 든든
        -> react 큰 cummity
        -> reat React Native 모바일 앱인데 자바스크립트로 할 수 있다네요...?
        -> 높은 상태관리 복잡도 state 아주 중요 이 역할을 하는.. 
        -> 보통 큰 규모의 경우 redux Mobx recoil

        <strong>명령어</strong>
        npx
        execute npm package binaries
        -> 한번에 찾아서 처리해줌

        npm application start 실행

        

        <!--Dom container - root dom의 시작점 -->
        <div id="root"></div>
        <!-- 리액트 가져오기 -->
        <script src="https://unpkg.com/react@17.0.2/umd/react.development.js" crossorigin></script>
        <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js" crossorigin></script>
        
        <!-- 리액트 컴포넌트 가져오기-->
        <script src="MyButton.js"></script>


        <strong>JSX</strong>
        자바스크립트 확장 문법
        javascript + XML/ HTML
        const element = < h1 >hello word < / h1 >;
        
        역할
        XML / HTML을 자바스크립트로 변환하는 과정을 거치게 됨 ->  React.createElment()
        JSX로 클래스를 만들고 ReactDom을 이용해 실제 화면에 랜더링
        const element = {
            html code
        }
        const element = React.createElement(
            'h1',
            {className : greating},
            'Hello world'
        )
        두 코드는 완전히 일치하지만, 위는 JSX, 아래는 javascript로 작성
        Jsx는 그 html 코드를 읽어서 javascript와 같은 형태로 변환해줌
        const element = {
            type: 'h1',
            props:{
                className : 'greeting',
                children : 'Hello world'
            }
            [children] 도 들어갈 수 있는데 이는 요소가 가진 자식 element
        }
        1. 가독성 향상  
        2. injection Attacks 방어 -> 입력창에 문자 같은 일반적인 값이 아닌 소스코드가 들어가서
                                    그 소스코드가 실행 되도록 하는 해킹방법
        보통 ReactDom은 기본적으로 임베딩하기 전에 모두 문자열로 변환함.

        <strong>사용법</strong>
        일단 모든 javascript를 지원하고 HTML/XML 지원함
        HTML에 {}안에 javascript 코들을 중간에 삽입할 수 있다.

        <strong>Rendering Elements</strong>
        Element
        리액트 앱을 구성하는 가장 작은 블록들. 
        보통 Element는 DOM element를 의미하며, 브라우저에서 보통 html 요소로 되어 있음. 
        화면에서 보이는 것들
        생김새 -> 자바스크립트 객체 형태 , 불변
        {
            type:'button',
            props:
                className:'btn'
                children: {
                    type:'b',
                    props:{
                        children: 'hello,element!'
                    }
                }
        }
        -> 이런 것을 만드는 것이 createElement
        만든 component들을 구성해서 그걸 또 다른 component에 넣으면
        그 component는 createElement를 했을 때 html code는 바로 element가 생성되고
        React component는 다시 자바스크립트 객체 형태가 돼서 합쳐진다.
        
        <strong>특징 및 레더링</strong>
        element = 불변 
        요소 생성 후 children이나 attributes 바꿀 수 없다.
        Component -> class 느낌 
        Element -> 객체들
        새로운 element를 만들어 기존에 연결되어 있는 곳에 바꿔 끼움
        그렇기 때문에 얼마나 자주 갱신되는가가 성능에 영향이 크다
        
        렌더링
        root id 안에 모든 react element들이 렌더링 되며 이를 root Dom node 단 하나
        그런데 수많은 추가 react를 연결하면 여러개의 root Domnode
        reactDom element는 React Dom에 존재하는 것이고 React Element는 브라우저에 존재함

        setInterval(객체, 100) 100초마다 객체 렌더링 -> 새로운 element 렌더링

        <strong>Component and Props</strong>
        component based -> 레고 블록
        input -> react component -> output
        props -> react component -> react element

        props -> property 속성
        component의 속성들
        붕어빵 틀 component
        붕어빵 Element
        들어간 속재료 props
        
        <strong>props</strong>
        값을 계속 변경하면 안됨 -> pure 해야함
        모든 리액트는 컴포넌트는 props를 직접 바꿀 수 없고 같은 props에 대해서는 항상
        같은 결과를 보여줄것
        -> 함수에 param이 바뀌면 안됨
        -> 같은 props는 항상 같은 결과

        component 사용 방식 
        Function 과 class
        Function이 편해서 많이 씀 -> Hook으로 발전 
        component는 항상 대문자로
        소문자는 보통 Dom tag -> 내장 component 
        큰 컴포넌트를 모두 조각내면 component 추출
        -> 재사용성 증가 -> 개발 속도 증가
        감싸고 감싸고 감싸는 마치 div같음..
        div에서 css를 분리해놓는것같은 마치 그런 느낌.. 대박.. 

        <strong>상태</strong>
        react component의 상태를 의미함
        state() -> 항상 개발자가 정의해서 사용
        렌더링이나 데이터 흐름에 사용되는 값만 state에 포함 시켜야함
        state가 변경될 때마다 재렌더링 되기 때문에 성능저하
        state == 자바스크립트 객체 -> 수정 안됨
        state를 변경할 때는 this.setState 함수를 이용해야함
        -> 렌더링과 관련되기 때문에 조심하세요

        생명주기 -> 주로 class의 개념 
        mounting updating unmounting
        생성자 실행 setstate forceupdate -> 여러번 업데이트 과정
        -> 사망 componentwillUnmount
        -> 자주 사용되는 개념이 아님

        component가 계속 존재하는 것이 아니라, 시간의 흐름에 따라 생성되고 업데이트가 되다가 사라진다.

        <strong>hook</strong>
        class -> 생성자에서 state를 정의
        setstate()를 통한 업데이트
        Lifecycle method 제공
        function -> state 사용 불가
        Lifecycle에 따른 기능 구현 불가

        hook은 중간에 끼어들어가서 함수 실행 시켜줌
        state, lifecycle이나 최적화 관련 함수 같은... 
        usestate() state훅을 사용해서 state 사용
        사용법
        <strong>useState</strong>
        const [변수명, set함수명] = useState(초기값);
        호출하면 return 값으로 배열이 나옴
        count 값을 usestate로 관리하겠다는 것임
        useStaet(0) 초기값 0이라는 말
        setCount를 이용해 count 값을 변경시키는데 변경되면 재렌더링이 일어남
        변수 각각마다 모두 다른 set을 가지고 있음
        <strong>useEffect </strong>
        서버 데이터 가져오거나 수동으로 Dom값 변경
        다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료될 수 없기 때문
        -> 생명주기 함수와 동일한 기능
        useEffect(effect함수, 의존성 배열);
        의존성 배열은 -> effect가 의존하고 있는 배열인데 여기서 말하는 effect는 리액트 효과같은 것
        하나라도 값이 변경하면 발생 -> 처음 렌더링 이후와 업데이트이후 재렌더링 이후에 실행
        useEffect(이펙트 함수,[]) 빈배열을 넣으면, effectfunction이 mount unmout시 단 한번만 실행
        의존성 배열을 생략해도 상관 없는데 그럼 컴포넌트가 업데이트될 때마다 호출된다. 

        예를 들어 useEffect로 브라우저 api를 사용해 title을 업데이트 한다고 하면
        const [count,setCount] = useState(0);
        Effect(()=>{
            document.title="${count}";
        })
        // 이 코드의 경우는 처음 생성될 때 즉 didmount일 때 한번 생성되고
        이후 계속 렌더링 돼서 update 될때마다 호출됨
        즉 useState가 작동될 때 모두 다시 렌더링 되기 때문에 update
        useEffect의 return함수는 unmount와 동일한 역할 소멸될 때
        하나의 훅에 여러개 사용 가능
        <strong>useMemo</strong>
        Memorized value를 리턴하는 hook이다
        Memoization이 무엇일까?
        최적화를 위한 개념 -> 연산량이 많은 함수 결과를 저장해 두었다가 값을 다시 호출할때 다시 모두 연산까지 호출하지 않고
        값을 저장해두었다가  불러오는 것
        const memoizedValue = useMemo(
            () => { 
                return computeExpensiveValue(의존성 변수1 , 의존성 변수2);
            },
            [의존성 변수1, 의존성변수2] // 의존성 배열
        );
        -> 이함수는 반드시 렌더링이 일어나는 동안 사용됨. 
        sideEffect가 실행될 때 서버에서 값을 받아오거나, 수동 Dom을 변경 작업등은 렌더링이 일어나는 동안 일어나면 안되기 때문에
        memo 함수에 넣으면 안되고 useEffect 훅을 사용해야함
        이것 또한 의존성 배열을 넣지 않으면 매 렌더링마다 함수가 실행됨 
        빈배열 -> 처음 생성mount시에만 호출된다. mount 이후에는 변경x

        <strong>useCallback</strong>
        useMemo와 거의 동일한데 다른점은 함수를 반환
        const memoizedValue = useMemo(
            () => { 
                doSomething(의존성 변수1 , 의존성 변수2);
            },
            [의존성 변수1, 의존성변수2] // 의존성 배열
        );
        useMemo와 거의 완전히 동일한 역할
        useCallback(함수, 의존성 배열)
        useMemo(()=>함수, 의존성 배열)

        <strong>useRef</strong>
        useRef는 Reference를 사용하기 위한 훅
        특정 컴포넌트에 접근할 수 있는 객체
        reObject.current에서 current는 현재 참조하고 있는 객체
        const refContainer = useRef(초기값); mount 해제전까지 계속 유지
        input에 ref성질과 비슷한데 다른점은 refhook은 자바스크립트 객체이기때문에
        여러 값이 저장 가능하다. 
        useRef는 내부 데이터가 변경되었을 때 별도로 알리지 않음
        current속성을 변경한다고 하더라도 재렌더링이 일어나지 않음
        
        다른 노드에 연결될 때 마다 collback ref를 이용하여 호출할 수 있음
        callback으로 ref를 구현하는데 그러는 이유는 ref는 별도의 current변경 알림이 없지만
        callback은 자식 component가 변경될 때마다 알려줌 

        <strong>hook의 조건</strong>
        반드시 최상위 레벨에서만 호출해야 한다. 
        반복문 조건문 중첩함수에서 훅 호출하면 안됨
        -> 컴포넌트가 렌더링 될 때마다 매번 같은 순서로 호출되어야 한다.
        리액트 함수 컴포넌트에서만 hook을 호출해야한다. 

        eslint-plugin-react-hook -> 강제 hook 규칙을 따르도록하는 플러그 인 ->자동으로 경고해줌
        create함수가 참조하는 모든 값을 의존성 배열에 넣어주어야한다. 

        <strong>Custom hook</strong>
        사용하는 이유는 재사용되는 여러 component에서 사용되는 반복되는 로직을
        custom hook으로 만들어 재사용
        두 소스코드에서 hook 반복적으로 사용되고 있다면 이름이 use로 시작하고 내부에서 다른 hook을 
        호출하는 하나의 자바스크립트 함수를 만들어 준다. 
        어떤 값을 리턴할지 등의 내용을 직접 개발자가 정함 
        --> 완전히 독립적

        <strong>Event</strong>
        어떠한 특징을 나타냄 -> 이벤트를 핸들링 한다.
        함수 그대로 전달 -> React
        String으로 전달 -> DOM
        class에서?
        EventHandler -> 사건 처리 = EventListener
        javascript 함수들이 기본적으로 bind되지 않기 때문에 callback에서 
        this를 사용하기 위해서는 바이딩을 해줘야함.
        bind를 하지 않으면 this.handleClick은 global scope에서 호출 되는데, 글로벌 스콥에서는 undefined이므로 사용 불가
        Arrow function을 사용해도 되지만() onClick에 함수를 만들어 넣는 형태) 렌더링이 추가적으로 발생하여 성능 저하 문제
        
        Function에서?
        const [isToggle, setIsToggleOn] = useSate(true);
        // 방법 1. 함수안에 함수로 정의
        function handleClick(){
            setIsToggleOn((isToggleOn)=> !isToggleOn);
        }
        //방법 2. arrow function을 사용하여 정의
        const handleClick = () => {
            setIsToggle((isToggle)=>!isToggleOn)
        }

        Event handler에 Argument는 어떻게 전달하는가?
        -> 함수에 전달할 데이터 
        -> 이벤트 핸들러에 전달해야 할 데이터
        onClick={(event)=> this.deletItem(id,event)}
        or
        onClick = {this.deletItmem.bind(this, id)}


        <strong>conditional rendering</strong>
        조건부 렌더링
        -> 프로그래밍 랜더링
        return html 내부에 작성할 수도 있고 따로 조건문을 빼도 됨
        javascript의 truthy와 falsy
        -> true지만 true로 여겨지지 않는 값
        ->false지만 false로 여겨지지 않는 값
        truthy
        true
        {}
        []
        number
        "0", "false" -> string 형태
        falsy
        false
        0,-0
        0n
        ""
        null
        undefined
        NaN

        Element variable
        외부작성
        true&&condition
        condition ? true:false
        특정 컴포넌트를 보고 싶지 않으면 null을 리턴하면 됨
        
        <strong>map</strong>
        map함수-> 배열의 값들을 매핑시켜줌 return  배열
        Listkey
        -> 어떤 값의 CRUD를 확인하기 위해 사용
        속한 집한 내에서만 고유하면 됨
        예를 들어 학교내에서는 학번이 중복되면 안됨
        하지만 다른 학교 사람이랑은 중복되어도 상관 없음
        사용법
        li 태그를 사용한다면 그 내부에 key값을 줘서 사용
        key ={number.toString()}
        key={map변수.id} // 그 id 값을 사용하는 것
        key ={map변수.index} // 현재 아이템에 index 고유한 아이디 없을때 만하세요
        map함수 꼭 key값 넣으세요


    </pre>

</body>
</html>